#! /usr/bin/env node

"use strict";
const path = require("path");
const fs = require("fs");
const exec = require("child_process").exec;

const DIST_PATH = "./dist";
const JS_PATH = path.join(DIST_PATH, "js");
const CSS_PATH = path.join(DIST_PATH, "css");
const LOCALE = path.join(DIST_PATH, "locale");

const fileName = path.join(JS_PATH, "mainSiteURLs.js");


// Find css and JS files
const findJs = fileFinder(JS_PATH, `-iname "*.js"`);
const findCss = fileFinder(CSS_PATH, `-iname "*.css" -or -iname "*.svg" -or -iname "*.png"`);
const findLocale = fileFinder(LOCALE, `-iname "*.js"`);
// Process and generate file
Promise.all([findJs, findCss, findLocale])
  .then(processResults)
  .then(generateTemplate)
  .then(writeFile)
  .then(() => console.log("Ok!"))
  .catch(err => console.error(err));

function fileFinder(dir, pattern) {
  return new Promise((resolve, reject) => {
    var command = `find ${dir} ${pattern}`;
    exec(command, (err, stdout) => {
      return (err) ? reject(err) : resolve(stdout);
    });
  });
}

function processResults(results) {
  const paths = results
    .reduce((current, next) => next.concat(current), [])
    .split("\n")
    .filter(item => item)
    .map(item => path.relative(DIST_PATH, item))
    .map(item => `  "${item}",`)
    .sort();
  return Promise.resolve(paths);
}

function generateTemplate(paths) {
  var contents = `/**
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */
/*global self*/
/*exports mainSiteURLs*/

/**
 * THIS FILE IS AUTOMATICALLY GENERATED!
 * DO NOT MODIFY OR IT WILL JUST GET TRASHED.
 *
 * See: ${path.relative(__dirname + "/..", __filename)}
 */
"use strict";
const mainSiteURLs = [// jshint ignore:line
  "./",
  "sw.js",
${paths.join("\n")}
].map(
  // Using URL API is very slow in workers because it does IPC.
  path => self.location.origin + "/" + path
);
`;
  return Promise.resolve(contents);
}

function writeFile(template) {
  return new Promise((resolve, reject) => {
    fs.writeFile(fileName, template, (err) => {
      return (err) ? reject(err) : resolve();
    });
  });
}
